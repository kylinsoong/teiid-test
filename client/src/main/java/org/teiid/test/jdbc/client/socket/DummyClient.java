package org.teiid.test.jdbc.client.socket;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Method;
import java.net.Socket;
import java.net.UnknownHostException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.util.concurrent.Future;

import org.teiid.client.DQP;
import org.teiid.client.RequestMessage;
import org.teiid.client.RequestMessage.ResultsMode;
import org.teiid.client.util.ResultsFuture;
import org.teiid.core.util.AccessibleBufferedInputStream;
import org.teiid.net.socket.Handshake;
import org.teiid.net.socket.Message;
import org.teiid.net.socket.ServiceInvocationStruct;
import org.teiid.netty.handler.codec.serialization.ObjectDecoderInputStream;
import org.teiid.netty.handler.codec.serialization.ObjectEncoderOutputStream;

public class DummyClient {

    @SuppressWarnings("resource")
    public static void main(String[] args) throws UnknownHostException, IOException, ClassNotFoundException {

        RequestMessage reqMsg = new RequestMessage();
        reqMsg.setCommands(new String[]{"SELECT * FROM Product"});
        reqMsg.setBatchedUpdate(false);
        reqMsg.setResultsMode(ResultsMode.EITHER);
        reqMsg.setReturnAutoGeneratedKeys(false);
        reqMsg.setDelaySerialization(true);
        reqMsg.setCursorType(ResultSet.TYPE_FORWARD_ONLY);
        reqMsg.setFetchSize(2048);
        reqMsg.setRowLimit(0);
        reqMsg.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
        reqMsg.setSync(false);
        reqMsg.setPartialResults(false);
        reqMsg.setValidationMode(false);
        reqMsg.setUseResultSetCache(false);
        reqMsg.setAnsiQuotedIdentifiers(true);
        reqMsg.setExecutionId(100);
        
        Class<?> targetClass = DQP.class;
        Method method = getExecuteRequest();
        
        Message message = new Message();
        message.setContents(new ServiceInvocationStruct(new Object[]{100, reqMsg}, method.getName(), targetClass));
        message.setMessageKey(Integer.valueOf(27));
        
        ObjectOutputStream outputStream;
        ObjectInputStream inputStream;
        
        Socket socket = new Socket("localhost", 31000);
        DataOutputStream out = new DataOutputStream(socket.getOutputStream());
        outputStream = new ObjectEncoderOutputStream(out, 1<<15);
//        write(outputStream, message);
        
        DataInputStream in = new DataInputStream(socket.getInputStream());
        ClassLoader cl = DummyClient.class.getClassLoader();
        inputStream = new ObjectDecoderInputStream(new AccessibleBufferedInputStream(socket.getInputStream(), 1<<15), cl, 33554432);
        
        int index = 1;
        while(true){
        	Object serverMsg = inputStream.readObject();
        	System.out.println(index++ + " times received server message");
        	if(serverMsg instanceof Handshake) {
        		Handshake handshake = Handshake.class.cast(serverMsg);
        		String version = handshake.getVersion();
        		handshake.setVersion();
        		System.out.println("Receive Server Handshake Message, doHandshake: " + version + " -> " + handshake.getVersion());
        		write(outputStream, handshake);
//    		    result.get();
        	} else {
        		System.out.println(serverMsg );
        	}
        	System.out.println("\n");
        }
        
    }

    private static Future<?> write(ObjectOutputStream outputStream, Object handshake) {
    	ResultsFuture<Void> result = new ResultsFuture<Void>();
	    try {
	        outputStream.writeObject(handshake);
	        outputStream.flush();     
	        outputStream.reset();
	    	result.getResultsReceiver().receiveResults(null);
	    } catch (IOException e) {
	    	result.getResultsReceiver().exceptionOccurred(e);
	    }
		return result;
	}

	private static Method getExecuteRequest() {
        for(Method m : DQP.class.getMethods()){
            if(m.getName().equals("executeRequest"))
            return m;
        }
        return null;
    }

}
